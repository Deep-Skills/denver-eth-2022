diff --git a/node_modules/@glazed/devtools/dist/lib.cjs b/node_modules/@glazed/devtools/dist/lib.cjs
index 5dac92d..0381eb7 100644
--- a/node_modules/@glazed/devtools/dist/lib.cjs
+++ b/node_modules/@glazed/devtools/dist/lib.cjs
@@ -1,2 +1,89 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var P=require("@ceramicnetwork/streamid"),j=require("@ceramicnetwork/stream-tile"),I=require("@glazed/constants"),se=require("@glazed/did-datastore-model"),ne=require("cids"),B=require("uint8arrays"),G=require("change-case"),re=require("ajv"),ae=require("ajv-formats"),oe=require("ajv/lib/refs/json-schema-secure.json");function _(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var ce=_(ne),X=_(re),le=_(ae),de=_(oe);function me(e){return typeof e=="string"?e:e.toString()}function w(e,t){return Object.entries(e).reduce((i,[r,n])=>(i[r]=t(n),i),{})}async function H(e,t){const i=await Promise.all(Object.values(e).map(r=>t(r)));return Object.keys(e).reduce((r,n,a)=>(r[n]=i[a],r),{})}function V({payload:e,signatures:t,link:i}){return{payload:e,signatures:t,link:i?new ce.default(i):void 0}}function z({payload:e,signatures:t,link:i}){return{payload:e,signatures:t,link:i?.toString()}}function O({jws:e,linkedBlock:t}){return{jws:V(e),linkedBlock:B.fromString(t,"base64pad")}}function T({jws:e,linkedBlock:t}){return{jws:z(e),linkedBlock:B.toString(t,"base64pad")}}function he(e){return w(e,t=>t.map(O))}function ue(e){return w(e,t=>t.map(T))}function W(e){return{...e,commits:e.commits.map(O)}}function b(e){return{schemas:w(e.schemas,t=>({...t,commits:t.commits.map(O)})),definitions:w(e.definitions,W),tiles:w(e.tiles,W)}}function k(e){return{...e,commits:e.commits.map(T)}}function Q(e){return{schemas:w(e.schemas,t=>({...t,commits:t.commits.map(T)})),definitions:w(e.definitions,k),tiles:w(e.tiles,k)}}const q={anchor:!1};async function $(e,t,i={}){const r=await j.TileDocument.create(e,t,i,q);return await e.pin.add(r.id),r}async function S(e,[t,...i]){const r=await j.TileDocument.createFromGenesis(e,t,q);await e.pin.add(r.id);for(const n of i)await e.applyCommit(r.id,n,q);return r}async function fe(e,t){return await H(t,async i=>await S(e,i))}function E(e){if(e.$comment?.startsWith(I.CIP88_REF_PREFIX)){const t=e.$comment.substr(I.CIP88_REF_PREFIX.length);if(t.length){const i=t.split("|");return i.sort(),i}}return null}function A(e,t=""){if(e.type==="string"){const i=E(e);return i!=null&&i.length>0?{[t]:i}:{}}return e.type==="array"?A(e.items,t):e.type==="object"&&e.properties!=null?Object.entries(e.properties).reduce((i,[r,n])=>{const a=t===""?r:`${t}.${r}`;return Object.assign(i,A(n,a))},{}):{}}var K=(e,t,i)=>{if(!t.has(e))throw TypeError("Cannot "+i)},s=(e,t,i)=>(K(e,t,"read from private field"),i?i.call(e):t.get(e)),v=(e,t,i)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,i)},we=(e,t,i,r)=>(K(e,t,"write to private field"),r?r.call(e,i):t.set(e,i),i),h,c,m,f,M;function pe(e){const t=typeof e=="string"?P.StreamRef.from(e):e;return[t.baseID.toString(),P.CommitID.isInstance(t)?t.toString():null]}function Y(e){return(typeof e=="string"?P.StreamRef.from(e):e).baseID.toString()}function R(e){return e.startsWith("did:key")}function Z(e){return R(e.metadata.controllers[0])}const Se=b(se.model);async function N(e){await Promise.all(Object.values(Se.schemas).map(async t=>await S(e,t.commits)))}async function F(e,t){const[i]=await Promise.all([Promise.all(Object.values(t.schemas).map(async a=>{const l=await S(e,a.commits);return[a.alias,l.commitId.toUrl()]})),N(e)]),[r,n]=await Promise.all([await Promise.all(Object.values(t.definitions).map(async a=>{const l=await S(e,a.commits);return[a.alias,l.id.toString()]})),await Promise.all(Object.values(t.tiles).map(async a=>{const l=await S(e,a.commits);return[a.alias,l.id.toString()]}))]);return{definitions:Object.fromEntries(r),schemas:Object.fromEntries(i),tiles:Object.fromEntries(n)}}async function ge(e,t){return await F(e,b(t))}const ee=class{constructor(e,t){v(this,h,{definitions:{},schemas:{},tiles:{}}),v(this,c,void 0),v(this,m,{definitions:{},schemas:{},tiles:{}}),v(this,f,{}),v(this,M,{}),we(this,c,e),t!=null&&this.addModel(t)}static fromJSON(e,t){return new ee(e,b(t))}get model(){return s(this,m)}get schemas(){return Object.keys(s(this,h).schemas).sort()}get definitions(){return Object.keys(s(this,h).definitions).sort()}get tiles(){return Object.keys(s(this,h).tiles).sort()}addModel(e){Object.assign(s(this,m).definitions,e.definitions),Object.assign(s(this,m).schemas,e.schemas),Object.assign(s(this,m).tiles,e.tiles);for(const[t,i]of Object.entries(e.schemas)){s(this,h).schemas[i.alias]=t;for(const r of Object.values(i.dependencies))for(const n of r)s(this,f)[n]==null&&(s(this,f)[n]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[n].schemas.add(t)}for(const[t,i]of Object.entries(e.definitions))s(this,h).definitions[i.alias]=t,s(this,f)[i.schema]==null&&(s(this,f)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[i.schema].definitions.add(t);for(const[t,i]of Object.entries(e.tiles))s(this,h).tiles[i.alias]=t,s(this,f)[i.schema]==null&&(s(this,f)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[i.schema].tiles.add(t)}addJSONModel(e){this.addModel(b(e))}async loadStream(e){const t=typeof e=="string"?e:e.baseID.toString();return s(this,M)[t]==null&&(s(this,M)[t]=this._loadAndValidateStream(t)),await s(this,M)[t]}async _loadAndValidateStream(e){const t=await j.TileDocument.load(s(this,c),e);if(t.anchorCommitIds.length!==0)throw new Error(`Invalid stream ${e}: contains anchor commit`);if(t.allCommitIds.length===1&&Z(t))return t;if((await Promise.all(t.allCommitIds.map(async n=>await j.TileDocument.load(s(this,c),n)))).find(n=>!Z(n))!=null)throw new Error(`Invalid stream ${e}: contains a commit authored by an unsupported DID`);return t}async loadCommits(e){return(await s(this,c).loadStreamCommits(e)).map(i=>i.value)}async loadSchema(e,t){const[i,r]=pe(e);if(r===null)throw new Error(`Expected CommitID to load schema: ${i}`);const n=s(this,m).schemas[i];if(n!=null){if(n.version!==r)throw new Error(`Another version for this schema is already set: ${n.version}`);if(t!=null&&n.alias!==t)throw new Error(`Another alias for this schema is already set: ${n.alias}`);return i}const[a,l]=await Promise.all([this.loadStream(r),this.loadCommits(i)]),o=a.content??{},d=t??o.title;if(d==null)throw new Error("Schema must have a title property or an alias must be provided");const u=await this.loadSchemaDependencies(o);return s(this,m).schemas[i]={alias:d,commits:l,dependencies:u,version:r},s(this,h).schemas[d]=i,i}async loadSchemaDependencies(e){const t=A(e),i=new Set;for(const a of Object.values(t))for(const l of a)i.add(l);const r=await Promise.all(Array.from(i).map(async a=>[a,await this.loadSchema(a)])),n=Object.fromEntries(r);return Object.entries(t).reduce((a,[l,o])=>(a[l]=o.map(d=>n[d]),a),{})}async create(e,t,i,r){switch(e){case"schema":return await this.createSchema(t,i);case"definition":return await this.createDefinition(t,i);case"tile":return await this.createTile(t,i,r);default:throw new Error(`Unsupported type: ${e}`)}}async usePublished(e,t,i){switch(e){case"schema":return await this.usePublishedSchema(t,i);case"definition":return await this.usePublishedDefinition(t,i);case"tile":return await this.usePublishedTile(t,i);default:throw new Error(`Unsupported type: ${e}`)}}getSchemaID(e){return s(this,h).schemas[e]??null}hasSchemaAlias(e){return this.getSchemaID(e)!=null}getSchema(e){return s(this,m).schemas[e]??null}getSchemaURL(e){const t=s(this,m).schemas[e];return t?P.CommitID.fromString(t.version).toUrl():null}getSchemaByAlias(e){const t=this.getSchemaID(e);return t?this.getSchema(t):null}async createSchema(e,t){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!R(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasSchemaAlias(e))throw new Error(`Schema ${e} already exists`);const[i,r]=await Promise.all([$(s(this,c),t),this.loadSchemaDependencies(t)]),n=i.id.toString();return s(this,m).schemas[n]={alias:e,commits:await this.loadCommits(n),dependencies:r,version:i.commitId.toString()},s(this,h).schemas[e]=n,n}async usePublishedSchema(e,t){if(e==null)throw new Error("Schema alias must be provided");return await this.loadSchema(t,e)}getDefinitionID(e){return s(this,h).definitions[e]??null}hasDefinitionAlias(e){return this.getDefinitionID(e)!=null}getDefinition(e){return s(this,m).definitions[e]??null}async createDefinition(e,t){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!R(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasDefinitionAlias(e))throw new Error(`Definition ${e} already exists`);await N(s(this,c));const[i,r]=await Promise.all([$(s(this,c),t,{schema:I.CIP11_DEFINITION_SCHEMA_URL}),this.loadSchema(t.schema)]),n=i.id.toString();return s(this,m).definitions[n]={alias:e,commits:await this.loadCommits(n),schema:r,version:i.commitId.toString()},s(this,h).definitions[e]=n,n}async usePublishedDefinition(e,t){if(this.hasDefinitionAlias(e))throw new Error(`Definition ${e} already exists`);const i=Y(t),[r,n]=await Promise.all([this.loadStream(t),this.loadCommits(i)]);return s(this,m).definitions[i]={alias:e,commits:n,schema:await this.loadSchema(r.content.schema),version:r.commitId.toString()},s(this,h).definitions[e]=i,i}getTileID(e){return s(this,h).tiles[e]??null}hasTileAlias(e){return this.getTileID(e)!=null}getTile(e){return s(this,m).tiles[e]??null}async createTile(e,t,i={}){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!R(s(this,c).did.id))throw new Error("Unsupported DID to create stream for model");if(this.hasTileAlias(e))throw new Error(`Tile ${e} already exists`);if(i.schema==null)throw new Error(`Missing schema to create tile ${e}`);const[r,n]=await Promise.all([$(s(this,c),t,i),this.loadSchema(i.schema)]),a=r.id.toString();return s(this,m).tiles[a]={alias:e,commits:await this.loadCommits(a),schema:n,version:r.commitId.toString()},s(this,h).tiles[e]=a,a}async usePublishedTile(e,t){if(this.hasTileAlias(e))throw new Error(`Tile ${e} already exists`);const i=Y(t),[r,n]=await Promise.all([this.loadStream(t),this.loadCommits(i)]);if(r.metadata.schema==null)throw new Error("Loaded tile has no schema defined");return s(this,m).tiles[i]={alias:e,commits:n,schema:await this.loadSchema(r.metadata.schema),version:r.commitId.toString()},s(this,h).tiles[e]=i,i}async toPublished(){return await F(s(this,c),s(this,m))}toJSON(){return Q(s(this,m))}};let ye=ee;h=new WeakMap,c=new WeakMap,m=new WeakMap,f=new WeakMap,M=new WeakMap;function L(e,t=""){const i=G.pascalCase(e);return i.startsWith(t)?i:t+i}function x(e,t,i,r){const n=t.title??"";if(t.type==="array")throw new Error("Unsupported item field of type array");if(t.type==="string"){const a=E(t);if(a==null)return{...t,type:"string"};const l=L(n,i),o={schemas:a,owner:r};return e.references[l]=o,{type:"reference",...o}}return t.type==="object"?{type:"object",name:C(e,t,{name:n,parent:i,owner:r})}:t}function C(e,t,i={}){const r=i.name??t.title;if(r==null)throw new Error("Schema must have a title");const n=L(r,i.parent);if(t.type==="string"){const a=E(t);a!=null&&(e.references[n]={schemas:a,owner:i.owner})}else if(t.type==="array"&&t.items!=null)e.lists[n]=x(e,t.items,n,i.owner);else if(t.type==="object"&&t.properties!=null){const a=t.required??[],l=Object.entries(t.properties).reduce((o,[d,u])=>{const g=u.title??d,p=G.camelCase(d),y={name:g,parent:n,owner:i.owner??n},D=a.includes(d);if(u.type==="string"){const J=E(u);if(J==null)o[p]={...u,required:D,type:"string"};else{const ie=L(g,n),U={schemas:J,owner:i.owner??n};e.references[ie]=U,o[p]={required:D,type:"reference",...U}}}else if(u.type==="array"){if(u.items==null)throw new Error(`Missing items in field ${d}`);o[p]={required:D,type:"list",name:C(e,u,y)}}else u.type==="object"?o[p]={required:D,type:"object",name:C(e,u,y)}:o[p]={...u,required:D};return o},{});e.objects[n]={fields:l,parents:i.parent?[i.parent]:null}}return n}async function De(e){const t={collections:{},index:{},lists:{},objects:{},referenced:{},references:{},roots:{}},i=e.schemas.map(async a=>{const l=e.getSchemaID(a),o=await e.loadStream(l),d=o.content;if(d==null)throw new Error(`Could not load schema ${a}`);const u=o.commitId.toUrl();if(d.$comment?.startsWith(I.CIP88_APPEND_COLLECTION_PREFIX)){const g=d.$comment.substr(I.CIP88_APPEND_COLLECTION_PREFIX.length);await e.loadSchema(g);const y=(await e.loadStream(g)).content?.properties?.contents?.items?.oneOf?.[0];if(y==null)throw new Error(`Could not extract item schema ${a}`);t.collections[a]={schema:u,item:x(t,y,a,a)},t.referenced[u]={type:"collection",name:a}}else t.referenced[u]={type:"object",name:C(t,d)}}),r=e.definitions.map(async a=>{const l=e.getDefinitionID(a),o=await e.loadStream(l),d=o.content;if(d==null)throw new Error(`Could not load definition ${a}`);t.index[a]={id:o.id.toString(),schema:d.schema}}),n=e.tiles.map(async a=>{const l=e.getTileID(a),o=await e.loadStream(l),{schema:d}=o.metadata;if(d==null)throw new Error(`Missing schema for tile ${a}`);t.roots[a]={id:o.id.toString(),schema:d}});return await Promise.all([...i,...r,...n]),t}const te=new X.default({strict:!1}).compile(de.default);function Ie(e){const t=new X.default;return le.default(t),t.compile(e),te(e)}exports.ModelManager=ye,exports.addModelSchema=C,exports.applyMap=w,exports.createGraphQLModel=De,exports.createModelDoc=$,exports.decodeDagJWS=V,exports.decodeDagJWSResult=O,exports.decodeEntryCommits=W,exports.decodeModel=b,exports.decodeSignedMap=he,exports.encodeDagJWS=z,exports.encodeDagJWSResult=T,exports.encodeEntryCommits=k,exports.encodeModel=Q,exports.encodeSignedMap=ue,exports.extractSchemaReferences=A,exports.getItemField=x,exports.getReference=E,exports.isSecureSchema=Ie,exports.promiseMap=H,exports.publishCommits=S,exports.publishDataStoreSchemas=N,exports.publishEncodedModel=ge,exports.publishModel=F,exports.publishSignedMap=fe,exports.streamIDToString=me,exports.validateSchemaSecure=te;
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var P=require("@ceramicnetwork/streamid"),j=require("@ceramicnetwork/stream-tile"),I=require("@glazed/constants"),se=require("@glazed/did-datastore-model"),ne=require("cids"),B=require("uint8arrays"),G=require("change-case"),re=require("ajv"),ae=require("ajv-formats"),oe={
+  "$schema": "http://json-schema.org/draft-07/schema#",
+  "$id": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/json-schema-secure.json#",
+  "title": "Meta-schema for the security assessment of JSON Schemas",
+  "description": "If a JSON AnySchema fails validation against this meta-schema, it may be unsafe to validate untrusted data",
+  "definitions": {
+    "schemaArray": {
+      "type": "array",
+      "minItems": 1,
+      "items": {"$ref": "#"}
+    }
+  },
+  "dependencies": {
+    "patternProperties": {
+      "description": "prevent slow validation of large property names",
+      "required": ["propertyNames"],
+      "properties": {
+        "propertyNames": {
+          "required": ["maxLength"]
+        }
+      }
+    },
+    "uniqueItems": {
+      "description": "prevent slow validation of large non-scalar arrays",
+      "if": {
+        "properties": {
+          "uniqueItems": {"const": true},
+          "items": {
+            "properties": {
+              "type": {
+                "anyOf": [
+                  {
+                    "enum": ["object", "array"]
+                  },
+                  {
+                    "type": "array",
+                    "contains": {"enum": ["object", "array"]}
+                  }
+                ]
+              }
+            }
+          }
+        }
+      },
+      "then": {
+        "required": ["maxItems"]
+      }
+    },
+    "pattern": {
+      "description": "prevent slow pattern matching of large strings",
+      "required": ["maxLength"]
+    },
+    "format": {
+      "description": "prevent slow format validation of large strings",
+      "required": ["maxLength"]
+    }
+  },
+  "properties": {
+    "additionalItems": {"$ref": "#"},
+    "additionalProperties": {"$ref": "#"},
+    "dependencies": {
+      "additionalProperties": {
+        "anyOf": [{"type": "array"}, {"$ref": "#"}]
+      }
+    },
+    "items": {
+      "anyOf": [{"$ref": "#"}, {"$ref": "#/definitions/schemaArray"}]
+    },
+    "definitions": {
+      "additionalProperties": {"$ref": "#"}
+    },
+    "patternProperties": {
+      "additionalProperties": {"$ref": "#"}
+    },
+    "properties": {
+      "additionalProperties": {"$ref": "#"}
+    },
+    "if": {"$ref": "#"},
+    "then": {"$ref": "#"},
+    "else": {"$ref": "#"},
+    "allOf": {"$ref": "#/definitions/schemaArray"},
+    "anyOf": {"$ref": "#/definitions/schemaArray"},
+    "oneOf": {"$ref": "#/definitions/schemaArray"},
+    "not": {"$ref": "#"},
+    "contains": {"$ref": "#"},
+    "propertyNames": {"$ref": "#"}
+  }
+};function _(e){return e&&typeof e=="object"&&"default"in e?e:{default:e}}var ce=_(ne),X=_(re),le=_(ae),de=_(oe);function me(e){return typeof e=="string"?e:e.toString()}function w(e,t){return Object.entries(e).reduce((i,[r,n])=>(i[r]=t(n),i),{})}async function H(e,t){const i=await Promise.all(Object.values(e).map(r=>t(r)));return Object.keys(e).reduce((r,n,a)=>(r[n]=i[a],r),{})}function V({payload:e,signatures:t,link:i}){return{payload:e,signatures:t,link:i?new ce.default(i):void 0}}function z({payload:e,signatures:t,link:i}){return{payload:e,signatures:t,link:i?.toString()}}function O({jws:e,linkedBlock:t}){return{jws:V(e),linkedBlock:B.fromString(t,"base64pad")}}function T({jws:e,linkedBlock:t}){return{jws:z(e),linkedBlock:B.toString(t,"base64pad")}}function he(e){return w(e,t=>t.map(O))}function ue(e){return w(e,t=>t.map(T))}function W(e){return{...e,commits:e.commits.map(O)}}function b(e){return{schemas:w(e.schemas,t=>({...t,commits:t.commits.map(O)})),definitions:w(e.definitions,W),tiles:w(e.tiles,W)}}function k(e){return{...e,commits:e.commits.map(T)}}function Q(e){return{schemas:w(e.schemas,t=>({...t,commits:t.commits.map(T)})),definitions:w(e.definitions,k),tiles:w(e.tiles,k)}}const q={anchor:!1};async function $(e,t,i={}){const r=await j.TileDocument.create(e,t,i,q);return await e.pin.add(r.id),r}async function S(e,[t,...i]){const r=await j.TileDocument.createFromGenesis(e,t,q);await e.pin.add(r.id);for(const n of i)await e.applyCommit(r.id,n,q);return r}async function fe(e,t){return await H(t,async i=>await S(e,i))}function E(e){if(e.$comment?.startsWith(I.CIP88_REF_PREFIX)){const t=e.$comment.substr(I.CIP88_REF_PREFIX.length);if(t.length){const i=t.split("|");return i.sort(),i}}return null}function A(e,t=""){if(e.type==="string"){const i=E(e);return i!=null&&i.length>0?{[t]:i}:{}}return e.type==="array"?A(e.items,t):e.type==="object"&&e.properties!=null?Object.entries(e.properties).reduce((i,[r,n])=>{const a=t===""?r:`${t}.${r}`;return Object.assign(i,A(n,a))},{}):{}}var K=(e,t,i)=>{if(!t.has(e))throw TypeError("Cannot "+i)},s=(e,t,i)=>(K(e,t,"read from private field"),i?i.call(e):t.get(e)),v=(e,t,i)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,i)},we=(e,t,i,r)=>(K(e,t,"write to private field"),r?r.call(e,i):t.set(e,i),i),h,c,m,f,M;function pe(e){const t=typeof e=="string"?P.StreamRef.from(e):e;return[t.baseID.toString(),P.CommitID.isInstance(t)?t.toString():null]}function Y(e){return(typeof e=="string"?P.StreamRef.from(e):e).baseID.toString()}function R(e){return e.startsWith("did:key")}function Z(e){return R(e.metadata.controllers[0])}const Se=b(se.model);async function N(e){await Promise.all(Object.values(Se.schemas).map(async t=>await S(e,t.commits)))}async function F(e,t){const[i]=await Promise.all([Promise.all(Object.values(t.schemas).map(async a=>{const l=await S(e,a.commits);return[a.alias,l.commitId.toUrl()]})),N(e)]),[r,n]=await Promise.all([await Promise.all(Object.values(t.definitions).map(async a=>{const l=await S(e,a.commits);return[a.alias,l.id.toString()]})),await Promise.all(Object.values(t.tiles).map(async a=>{const l=await S(e,a.commits);return[a.alias,l.id.toString()]}))]);return{definitions:Object.fromEntries(r),schemas:Object.fromEntries(i),tiles:Object.fromEntries(n)}}async function ge(e,t){return await F(e,b(t))}const ee=class{constructor(e,t){v(this,h,{definitions:{},schemas:{},tiles:{}}),v(this,c,void 0),v(this,m,{definitions:{},schemas:{},tiles:{}}),v(this,f,{}),v(this,M,{}),we(this,c,e),t!=null&&this.addModel(t)}static fromJSON(e,t){return new ee(e,b(t))}get model(){return s(this,m)}get schemas(){return Object.keys(s(this,h).schemas).sort()}get definitions(){return Object.keys(s(this,h).definitions).sort()}get tiles(){return Object.keys(s(this,h).tiles).sort()}addModel(e){Object.assign(s(this,m).definitions,e.definitions),Object.assign(s(this,m).schemas,e.schemas),Object.assign(s(this,m).tiles,e.tiles);for(const[t,i]of Object.entries(e.schemas)){s(this,h).schemas[i.alias]=t;for(const r of Object.values(i.dependencies))for(const n of r)s(this,f)[n]==null&&(s(this,f)[n]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[n].schemas.add(t)}for(const[t,i]of Object.entries(e.definitions))s(this,h).definitions[i.alias]=t,s(this,f)[i.schema]==null&&(s(this,f)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[i.schema].definitions.add(t);for(const[t,i]of Object.entries(e.tiles))s(this,h).tiles[i.alias]=t,s(this,f)[i.schema]==null&&(s(this,f)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[i.schema].tiles.add(t)}addJSONModel(e){this.addModel(b(e))}async loadStream(e){const t=typeof e=="string"?e:e.baseID.toString();return s(this,M)[t]==null&&(s(this,M)[t]=this._loadAndValidateStream(t)),await s(this,M)[t]}async _loadAndValidateStream(e){const t=await j.TileDocument.load(s(this,c),e);if(t.anchorCommitIds.length!==0)throw new Error(`Invalid stream ${e}: contains anchor commit`);if(t.allCommitIds.length===1&&Z(t))return t;if((await Promise.all(t.allCommitIds.map(async n=>await j.TileDocument.load(s(this,c),n)))).find(n=>!Z(n))!=null)throw new Error(`Invalid stream ${e}: contains a commit authored by an unsupported DID`);return t}async loadCommits(e){return(await s(this,c).loadStreamCommits(e)).map(i=>i.value)}async loadSchema(e,t){const[i,r]=pe(e);if(r===null)throw new Error(`Expected CommitID to load schema: ${i}`);const n=s(this,m).schemas[i];if(n!=null){if(n.version!==r)throw new Error(`Another version for this schema is already set: ${n.version}`);if(t!=null&&n.alias!==t)throw new Error(`Another alias for this schema is already set: ${n.alias}`);return i}const[a,l]=await Promise.all([this.loadStream(r),this.loadCommits(i)]),o=a.content??{},d=t??o.title;if(d==null)throw new Error("Schema must have a title property or an alias must be provided");const u=await this.loadSchemaDependencies(o);return s(this,m).schemas[i]={alias:d,commits:l,dependencies:u,version:r},s(this,h).schemas[d]=i,i}async loadSchemaDependencies(e){const t=A(e),i=new Set;for(const a of Object.values(t))for(const l of a)i.add(l);const r=await Promise.all(Array.from(i).map(async a=>[a,await this.loadSchema(a)])),n=Object.fromEntries(r);return Object.entries(t).reduce((a,[l,o])=>(a[l]=o.map(d=>n[d]),a),{})}async create(e,t,i,r){switch(e){case"schema":return await this.createSchema(t,i);case"definition":return await this.createDefinition(t,i);case"tile":return await this.createTile(t,i,r);default:throw new Error(`Unsupported type: ${e}`)}}async usePublished(e,t,i){switch(e){case"schema":return await this.usePublishedSchema(t,i);case"definition":return await this.usePublishedDefinition(t,i);case"tile":return await this.usePublishedTile(t,i);default:throw new Error(`Unsupported type: ${e}`)}}getSchemaID(e){return s(this,h).schemas[e]??null}hasSchemaAlias(e){return this.getSchemaID(e)!=null}getSchema(e){return s(this,m).schemas[e]??null}getSchemaURL(e){const t=s(this,m).schemas[e];return t?P.CommitID.fromString(t.version).toUrl():null}getSchemaByAlias(e){const t=this.getSchemaID(e);return t?this.getSchema(t):null}async createSchema(e,t){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!R(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasSchemaAlias(e))throw new Error(`Schema ${e} already exists`);const[i,r]=await Promise.all([$(s(this,c),t),this.loadSchemaDependencies(t)]),n=i.id.toString();return s(this,m).schemas[n]={alias:e,commits:await this.loadCommits(n),dependencies:r,version:i.commitId.toString()},s(this,h).schemas[e]=n,n}async usePublishedSchema(e,t){if(e==null)throw new Error("Schema alias must be provided");return await this.loadSchema(t,e)}getDefinitionID(e){return s(this,h).definitions[e]??null}hasDefinitionAlias(e){return this.getDefinitionID(e)!=null}getDefinition(e){return s(this,m).definitions[e]??null}async createDefinition(e,t){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!R(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasDefinitionAlias(e))throw new Error(`Definition ${e} already exists`);await N(s(this,c));const[i,r]=await Promise.all([$(s(this,c),t,{schema:I.CIP11_DEFINITION_SCHEMA_URL}),this.loadSchema(t.schema)]),n=i.id.toString();return s(this,m).definitions[n]={alias:e,commits:await this.loadCommits(n),schema:r,version:i.commitId.toString()},s(this,h).definitions[e]=n,n}async usePublishedDefinition(e,t){if(this.hasDefinitionAlias(e))throw new Error(`Definition ${e} already exists`);const i=Y(t),[r,n]=await Promise.all([this.loadStream(t),this.loadCommits(i)]);return s(this,m).definitions[i]={alias:e,commits:n,schema:await this.loadSchema(r.content.schema),version:r.commitId.toString()},s(this,h).definitions[e]=i,i}getTileID(e){return s(this,h).tiles[e]??null}hasTileAlias(e){return this.getTileID(e)!=null}getTile(e){return s(this,m).tiles[e]??null}async createTile(e,t,i={}){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!R(s(this,c).did.id))throw new Error("Unsupported DID to create stream for model");if(this.hasTileAlias(e))throw new Error(`Tile ${e} already exists`);if(i.schema==null)throw new Error(`Missing schema to create tile ${e}`);const[r,n]=await Promise.all([$(s(this,c),t,i),this.loadSchema(i.schema)]),a=r.id.toString();return s(this,m).tiles[a]={alias:e,commits:await this.loadCommits(a),schema:n,version:r.commitId.toString()},s(this,h).tiles[e]=a,a}async usePublishedTile(e,t){if(this.hasTileAlias(e))throw new Error(`Tile ${e} already exists`);const i=Y(t),[r,n]=await Promise.all([this.loadStream(t),this.loadCommits(i)]);if(r.metadata.schema==null)throw new Error("Loaded tile has no schema defined");return s(this,m).tiles[i]={alias:e,commits:n,schema:await this.loadSchema(r.metadata.schema),version:r.commitId.toString()},s(this,h).tiles[e]=i,i}async toPublished(){return await F(s(this,c),s(this,m))}toJSON(){return Q(s(this,m))}};let ye=ee;h=new WeakMap,c=new WeakMap,m=new WeakMap,f=new WeakMap,M=new WeakMap;function L(e,t=""){const i=G.pascalCase(e);return i.startsWith(t)?i:t+i}function x(e,t,i,r){const n=t.title??"";if(t.type==="array")throw new Error("Unsupported item field of type array");if(t.type==="string"){const a=E(t);if(a==null)return{...t,type:"string"};const l=L(n,i),o={schemas:a,owner:r};return e.references[l]=o,{type:"reference",...o}}return t.type==="object"?{type:"object",name:C(e,t,{name:n,parent:i,owner:r})}:t}function C(e,t,i={}){const r=i.name??t.title;if(r==null)throw new Error("Schema must have a title");const n=L(r,i.parent);if(t.type==="string"){const a=E(t);a!=null&&(e.references[n]={schemas:a,owner:i.owner})}else if(t.type==="array"&&t.items!=null)e.lists[n]=x(e,t.items,n,i.owner);else if(t.type==="object"&&t.properties!=null){const a=t.required??[],l=Object.entries(t.properties).reduce((o,[d,u])=>{const g=u.title??d,p=G.camelCase(d),y={name:g,parent:n,owner:i.owner??n},D=a.includes(d);if(u.type==="string"){const J=E(u);if(J==null)o[p]={...u,required:D,type:"string"};else{const ie=L(g,n),U={schemas:J,owner:i.owner??n};e.references[ie]=U,o[p]={required:D,type:"reference",...U}}}else if(u.type==="array"){if(u.items==null)throw new Error(`Missing items in field ${d}`);o[p]={required:D,type:"list",name:C(e,u,y)}}else u.type==="object"?o[p]={required:D,type:"object",name:C(e,u,y)}:o[p]={...u,required:D};return o},{});e.objects[n]={fields:l,parents:i.parent?[i.parent]:null}}return n}async function De(e){const t={collections:{},index:{},lists:{},objects:{},referenced:{},references:{},roots:{}},i=e.schemas.map(async a=>{const l=e.getSchemaID(a),o=await e.loadStream(l),d=o.content;if(d==null)throw new Error(`Could not load schema ${a}`);const u=o.commitId.toUrl();if(d.$comment?.startsWith(I.CIP88_APPEND_COLLECTION_PREFIX)){const g=d.$comment.substr(I.CIP88_APPEND_COLLECTION_PREFIX.length);await e.loadSchema(g);const y=(await e.loadStream(g)).content?.properties?.contents?.items?.oneOf?.[0];if(y==null)throw new Error(`Could not extract item schema ${a}`);t.collections[a]={schema:u,item:x(t,y,a,a)},t.referenced[u]={type:"collection",name:a}}else t.referenced[u]={type:"object",name:C(t,d)}}),r=e.definitions.map(async a=>{const l=e.getDefinitionID(a),o=await e.loadStream(l),d=o.content;if(d==null)throw new Error(`Could not load definition ${a}`);t.index[a]={id:o.id.toString(),schema:d.schema}}),n=e.tiles.map(async a=>{const l=e.getTileID(a),o=await e.loadStream(l),{schema:d}=o.metadata;if(d==null)throw new Error(`Missing schema for tile ${a}`);t.roots[a]={id:o.id.toString(),schema:d}});return await Promise.all([...i,...r,...n]),t}const te=new X.default({strict:!1}).compile(de.default);function Ie(e){const t=new X.default;return le.default(t),t.compile(e),te(e)}exports.ModelManager=ye,exports.addModelSchema=C,exports.applyMap=w,exports.createGraphQLModel=De,exports.createModelDoc=$,exports.decodeDagJWS=V,exports.decodeDagJWSResult=O,exports.decodeEntryCommits=W,exports.decodeModel=b,exports.decodeSignedMap=he,exports.encodeDagJWS=z,exports.encodeDagJWSResult=T,exports.encodeEntryCommits=k,exports.encodeModel=Q,exports.encodeSignedMap=ue,exports.extractSchemaReferences=A,exports.getItemField=x,exports.getReference=E,exports.isSecureSchema=Ie,exports.promiseMap=H,exports.publishCommits=S,exports.publishDataStoreSchemas=N,exports.publishEncodedModel=ge,exports.publishModel=F,exports.publishSignedMap=fe,exports.streamIDToString=me,exports.validateSchemaSecure=te;
 //# sourceMappingURL=lib.cjs.map
diff --git a/node_modules/@glazed/devtools/dist/lib.mjs b/node_modules/@glazed/devtools/dist/lib.mjs
index ce44401..3765d95 100644
--- a/node_modules/@glazed/devtools/dist/lib.mjs
+++ b/node_modules/@glazed/devtools/dist/lib.mjs
@@ -1,2 +1,89 @@
-import{CommitID as F,StreamRef as J}from"@ceramicnetwork/streamid";import{TileDocument as O}from"@ceramicnetwork/stream-tile";import{CIP88_REF_PREFIX as B,CIP11_DEFINITION_SCHEMA_URL as it,CIP88_APPEND_COLLECTION_PREFIX as q}from"@glazed/constants";import{model as st}from"@glazed/did-datastore-model";import nt from"cids";import{fromString as rt,toString as ot}from"uint8arrays";import{camelCase as at,pascalCase as ct}from"change-case";import G from"ajv";import lt from"ajv-formats";import mt from"ajv/lib/refs/json-schema-secure.json";function dt(t){return typeof t=="string"?t:t.toString()}function w(t,e){return Object.entries(t).reduce((i,[r,n])=>(i[r]=e(n),i),{})}async function H(t,e){const i=await Promise.all(Object.values(t).map(r=>e(r)));return Object.keys(t).reduce((r,n,o)=>(r[n]=i[o],r),{})}function V({payload:t,signatures:e,link:i}){return{payload:t,signatures:e,link:i?new nt(i):void 0}}function X({payload:t,signatures:e,link:i}){return{payload:t,signatures:e,link:i?.toString()}}function j({jws:t,linkedBlock:e}){return{jws:V(t),linkedBlock:rt(e,"base64pad")}}function M({jws:t,linkedBlock:e}){return{jws:X(t),linkedBlock:ot(e,"base64pad")}}function ht(t){return w(t,e=>e.map(j))}function ut(t){return w(t,e=>e.map(M))}function T(t){return{...t,commits:t.commits.map(j)}}function I(t){return{schemas:w(t.schemas,e=>({...e,commits:e.commits.map(j)})),definitions:w(t.definitions,T),tiles:w(t.tiles,T)}}function A(t){return{...t,commits:t.commits.map(M)}}function Q(t){return{schemas:w(t.schemas,e=>({...e,commits:e.commits.map(M)})),definitions:w(t.definitions,A),tiles:w(t.tiles,A)}}const k={anchor:!1};async function v(t,e,i={}){const r=await O.create(t,e,i,k);return await t.pin.add(r.id),r}async function S(t,[e,...i]){const r=await O.createFromGenesis(t,e,k);await t.pin.add(r.id);for(const n of i)await t.applyCommit(r.id,n,k);return r}async function ft(t,e){return await H(e,async i=>await S(t,i))}function b(t){if(t.$comment?.startsWith(B)){const e=t.$comment.substr(B.length);if(e.length){const i=e.split("|");return i.sort(),i}}return null}function $(t,e=""){if(t.type==="string"){const i=b(t);return i!=null&&i.length>0?{[e]:i}:{}}return t.type==="array"?$(t.items,e):t.type==="object"&&t.properties!=null?Object.entries(t.properties).reduce((i,[r,n])=>{const o=e===""?r:`${e}.${r}`;return Object.assign(i,$(n,o))},{}):{}}var z=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},s=(t,e,i)=>(z(t,e,"read from private field"),i?i.call(t):e.get(t)),E=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},wt=(t,e,i,r)=>(z(t,e,"write to private field"),r?r.call(t,i):e.set(t,i),i),h,c,d,f,C;function pt(t){const e=typeof t=="string"?J.from(t):t;return[e.baseID.toString(),F.isInstance(e)?e.toString():null]}function K(t){return(typeof t=="string"?J.from(t):t).baseID.toString()}function _(t){return t.startsWith("did:key")}function Y(t){return _(t.metadata.controllers[0])}const St=I(st);async function W(t){await Promise.all(Object.values(St.schemas).map(async e=>await S(t,e.commits)))}async function x(t,e){const[i]=await Promise.all([Promise.all(Object.values(e.schemas).map(async o=>{const l=await S(t,o.commits);return[o.alias,l.commitId.toUrl()]})),W(t)]),[r,n]=await Promise.all([await Promise.all(Object.values(e.definitions).map(async o=>{const l=await S(t,o.commits);return[o.alias,l.id.toString()]})),await Promise.all(Object.values(e.tiles).map(async o=>{const l=await S(t,o.commits);return[o.alias,l.id.toString()]}))]);return{definitions:Object.fromEntries(r),schemas:Object.fromEntries(i),tiles:Object.fromEntries(n)}}async function yt(t,e){return await x(t,I(e))}const Z=class{constructor(t,e){E(this,h,{definitions:{},schemas:{},tiles:{}}),E(this,c,void 0),E(this,d,{definitions:{},schemas:{},tiles:{}}),E(this,f,{}),E(this,C,{}),wt(this,c,t),e!=null&&this.addModel(e)}static fromJSON(t,e){return new Z(t,I(e))}get model(){return s(this,d)}get schemas(){return Object.keys(s(this,h).schemas).sort()}get definitions(){return Object.keys(s(this,h).definitions).sort()}get tiles(){return Object.keys(s(this,h).tiles).sort()}addModel(t){Object.assign(s(this,d).definitions,t.definitions),Object.assign(s(this,d).schemas,t.schemas),Object.assign(s(this,d).tiles,t.tiles);for(const[e,i]of Object.entries(t.schemas)){s(this,h).schemas[i.alias]=e;for(const r of Object.values(i.dependencies))for(const n of r)s(this,f)[n]==null&&(s(this,f)[n]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[n].schemas.add(e)}for(const[e,i]of Object.entries(t.definitions))s(this,h).definitions[i.alias]=e,s(this,f)[i.schema]==null&&(s(this,f)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[i.schema].definitions.add(e);for(const[e,i]of Object.entries(t.tiles))s(this,h).tiles[i.alias]=e,s(this,f)[i.schema]==null&&(s(this,f)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[i.schema].tiles.add(e)}addJSONModel(t){this.addModel(I(t))}async loadStream(t){const e=typeof t=="string"?t:t.baseID.toString();return s(this,C)[e]==null&&(s(this,C)[e]=this._loadAndValidateStream(e)),await s(this,C)[e]}async _loadAndValidateStream(t){const e=await O.load(s(this,c),t);if(e.anchorCommitIds.length!==0)throw new Error(`Invalid stream ${t}: contains anchor commit`);if(e.allCommitIds.length===1&&Y(e))return e;if((await Promise.all(e.allCommitIds.map(async n=>await O.load(s(this,c),n)))).find(n=>!Y(n))!=null)throw new Error(`Invalid stream ${t}: contains a commit authored by an unsupported DID`);return e}async loadCommits(t){return(await s(this,c).loadStreamCommits(t)).map(i=>i.value)}async loadSchema(t,e){const[i,r]=pt(t);if(r===null)throw new Error(`Expected CommitID to load schema: ${i}`);const n=s(this,d).schemas[i];if(n!=null){if(n.version!==r)throw new Error(`Another version for this schema is already set: ${n.version}`);if(e!=null&&n.alias!==e)throw new Error(`Another alias for this schema is already set: ${n.alias}`);return i}const[o,l]=await Promise.all([this.loadStream(r),this.loadCommits(i)]),a=o.content??{},m=e??a.title;if(m==null)throw new Error("Schema must have a title property or an alias must be provided");const u=await this.loadSchemaDependencies(a);return s(this,d).schemas[i]={alias:m,commits:l,dependencies:u,version:r},s(this,h).schemas[m]=i,i}async loadSchemaDependencies(t){const e=$(t),i=new Set;for(const o of Object.values(e))for(const l of o)i.add(l);const r=await Promise.all(Array.from(i).map(async o=>[o,await this.loadSchema(o)])),n=Object.fromEntries(r);return Object.entries(e).reduce((o,[l,a])=>(o[l]=a.map(m=>n[m]),o),{})}async create(t,e,i,r){switch(t){case"schema":return await this.createSchema(e,i);case"definition":return await this.createDefinition(e,i);case"tile":return await this.createTile(e,i,r);default:throw new Error(`Unsupported type: ${t}`)}}async usePublished(t,e,i){switch(t){case"schema":return await this.usePublishedSchema(e,i);case"definition":return await this.usePublishedDefinition(e,i);case"tile":return await this.usePublishedTile(e,i);default:throw new Error(`Unsupported type: ${t}`)}}getSchemaID(t){return s(this,h).schemas[t]??null}hasSchemaAlias(t){return this.getSchemaID(t)!=null}getSchema(t){return s(this,d).schemas[t]??null}getSchemaURL(t){const e=s(this,d).schemas[t];return e?F.fromString(e.version).toUrl():null}getSchemaByAlias(t){const e=this.getSchemaID(t);return e?this.getSchema(e):null}async createSchema(t,e){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!_(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasSchemaAlias(t))throw new Error(`Schema ${t} already exists`);const[i,r]=await Promise.all([v(s(this,c),e),this.loadSchemaDependencies(e)]),n=i.id.toString();return s(this,d).schemas[n]={alias:t,commits:await this.loadCommits(n),dependencies:r,version:i.commitId.toString()},s(this,h).schemas[t]=n,n}async usePublishedSchema(t,e){if(t==null)throw new Error("Schema alias must be provided");return await this.loadSchema(e,t)}getDefinitionID(t){return s(this,h).definitions[t]??null}hasDefinitionAlias(t){return this.getDefinitionID(t)!=null}getDefinition(t){return s(this,d).definitions[t]??null}async createDefinition(t,e){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!_(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasDefinitionAlias(t))throw new Error(`Definition ${t} already exists`);await W(s(this,c));const[i,r]=await Promise.all([v(s(this,c),e,{schema:it}),this.loadSchema(e.schema)]),n=i.id.toString();return s(this,d).definitions[n]={alias:t,commits:await this.loadCommits(n),schema:r,version:i.commitId.toString()},s(this,h).definitions[t]=n,n}async usePublishedDefinition(t,e){if(this.hasDefinitionAlias(t))throw new Error(`Definition ${t} already exists`);const i=K(e),[r,n]=await Promise.all([this.loadStream(e),this.loadCommits(i)]);return s(this,d).definitions[i]={alias:t,commits:n,schema:await this.loadSchema(r.content.schema),version:r.commitId.toString()},s(this,h).definitions[t]=i,i}getTileID(t){return s(this,h).tiles[t]??null}hasTileAlias(t){return this.getTileID(t)!=null}getTile(t){return s(this,d).tiles[t]??null}async createTile(t,e,i={}){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!_(s(this,c).did.id))throw new Error("Unsupported DID to create stream for model");if(this.hasTileAlias(t))throw new Error(`Tile ${t} already exists`);if(i.schema==null)throw new Error(`Missing schema to create tile ${t}`);const[r,n]=await Promise.all([v(s(this,c),e,i),this.loadSchema(i.schema)]),o=r.id.toString();return s(this,d).tiles[o]={alias:t,commits:await this.loadCommits(o),schema:n,version:r.commitId.toString()},s(this,h).tiles[t]=o,o}async usePublishedTile(t,e){if(this.hasTileAlias(t))throw new Error(`Tile ${t} already exists`);const i=K(e),[r,n]=await Promise.all([this.loadStream(e),this.loadCommits(i)]);if(r.metadata.schema==null)throw new Error("Loaded tile has no schema defined");return s(this,d).tiles[i]={alias:t,commits:n,schema:await this.loadSchema(r.metadata.schema),version:r.commitId.toString()},s(this,h).tiles[t]=i,i}async toPublished(){return await x(s(this,c),s(this,d))}toJSON(){return Q(s(this,d))}};let gt=Z;h=new WeakMap,c=new WeakMap,d=new WeakMap,f=new WeakMap,C=new WeakMap;function N(t,e=""){const i=ct(t);return i.startsWith(e)?i:e+i}function R(t,e,i,r){const n=e.title??"";if(e.type==="array")throw new Error("Unsupported item field of type array");if(e.type==="string"){const o=b(e);if(o==null)return{...e,type:"string"};const l=N(n,i),a={schemas:o,owner:r};return t.references[l]=a,{type:"reference",...a}}return e.type==="object"?{type:"object",name:P(t,e,{name:n,parent:i,owner:r})}:e}function P(t,e,i={}){const r=i.name??e.title;if(r==null)throw new Error("Schema must have a title");const n=N(r,i.parent);if(e.type==="string"){const o=b(e);o!=null&&(t.references[n]={schemas:o,owner:i.owner})}else if(e.type==="array"&&e.items!=null)t.lists[n]=R(t,e.items,n,i.owner);else if(e.type==="object"&&e.properties!=null){const o=e.required??[],l=Object.entries(e.properties).reduce((a,[m,u])=>{const y=u.title??m,p=at(m),g={name:y,parent:n,owner:i.owner??n},D=o.includes(m);if(u.type==="string"){const U=b(u);if(U==null)a[p]={...u,required:D,type:"string"};else{const et=N(y,n),L={schemas:U,owner:i.owner??n};t.references[et]=L,a[p]={required:D,type:"reference",...L}}}else if(u.type==="array"){if(u.items==null)throw new Error(`Missing items in field ${m}`);a[p]={required:D,type:"list",name:P(t,u,g)}}else u.type==="object"?a[p]={required:D,type:"object",name:P(t,u,g)}:a[p]={...u,required:D};return a},{});t.objects[n]={fields:l,parents:i.parent?[i.parent]:null}}return n}async function Dt(t){const e={collections:{},index:{},lists:{},objects:{},referenced:{},references:{},roots:{}},i=t.schemas.map(async o=>{const l=t.getSchemaID(o),a=await t.loadStream(l),m=a.content;if(m==null)throw new Error(`Could not load schema ${o}`);const u=a.commitId.toUrl();if(m.$comment?.startsWith(q)){const y=m.$comment.substr(q.length);await t.loadSchema(y);const g=(await t.loadStream(y)).content?.properties?.contents?.items?.oneOf?.[0];if(g==null)throw new Error(`Could not extract item schema ${o}`);e.collections[o]={schema:u,item:R(e,g,o,o)},e.referenced[u]={type:"collection",name:o}}else e.referenced[u]={type:"object",name:P(e,m)}}),r=t.definitions.map(async o=>{const l=t.getDefinitionID(o),a=await t.loadStream(l),m=a.content;if(m==null)throw new Error(`Could not load definition ${o}`);e.index[o]={id:a.id.toString(),schema:m.schema}}),n=t.tiles.map(async o=>{const l=t.getTileID(o),a=await t.loadStream(l),{schema:m}=a.metadata;if(m==null)throw new Error(`Missing schema for tile ${o}`);e.roots[o]={id:a.id.toString(),schema:m}});return await Promise.all([...i,...r,...n]),e}const tt=new G({strict:!1}).compile(mt);function It(t){const e=new G;return lt(e),e.compile(t),tt(t)}export{gt as ModelManager,P as addModelSchema,w as applyMap,Dt as createGraphQLModel,v as createModelDoc,V as decodeDagJWS,j as decodeDagJWSResult,T as decodeEntryCommits,I as decodeModel,ht as decodeSignedMap,X as encodeDagJWS,M as encodeDagJWSResult,A as encodeEntryCommits,Q as encodeModel,ut as encodeSignedMap,$ as extractSchemaReferences,R as getItemField,b as getReference,It as isSecureSchema,H as promiseMap,S as publishCommits,W as publishDataStoreSchemas,yt as publishEncodedModel,x as publishModel,ft as publishSignedMap,dt as streamIDToString,tt as validateSchemaSecure};
+import{CommitID as F,StreamRef as J}from"@ceramicnetwork/streamid";import{TileDocument as O}from"@ceramicnetwork/stream-tile";import{CIP88_REF_PREFIX as B,CIP11_DEFINITION_SCHEMA_URL as it,CIP88_APPEND_COLLECTION_PREFIX as q}from"@glazed/constants";import{model as st}from"@glazed/did-datastore-model";import nt from"cids";import{fromString as rt,toString as ot}from"uint8arrays";import{camelCase as at,pascalCase as ct}from"change-case";import G from"ajv";import lt from"ajv-formats";const mt = {
+  "$schema": "http://json-schema.org/draft-07/schema#",
+  "$id": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/json-schema-secure.json#",
+  "title": "Meta-schema for the security assessment of JSON Schemas",
+  "description": "If a JSON AnySchema fails validation against this meta-schema, it may be unsafe to validate untrusted data",
+  "definitions": {
+    "schemaArray": {
+      "type": "array",
+      "minItems": 1,
+      "items": {"$ref": "#"}
+    }
+  },
+  "dependencies": {
+    "patternProperties": {
+      "description": "prevent slow validation of large property names",
+      "required": ["propertyNames"],
+      "properties": {
+        "propertyNames": {
+          "required": ["maxLength"]
+        }
+      }
+    },
+    "uniqueItems": {
+      "description": "prevent slow validation of large non-scalar arrays",
+      "if": {
+        "properties": {
+          "uniqueItems": {"const": true},
+          "items": {
+            "properties": {
+              "type": {
+                "anyOf": [
+                  {
+                    "enum": ["object", "array"]
+                  },
+                  {
+                    "type": "array",
+                    "contains": {"enum": ["object", "array"]}
+                  }
+                ]
+              }
+            }
+          }
+        }
+      },
+      "then": {
+        "required": ["maxItems"]
+      }
+    },
+    "pattern": {
+      "description": "prevent slow pattern matching of large strings",
+      "required": ["maxLength"]
+    },
+    "format": {
+      "description": "prevent slow format validation of large strings",
+      "required": ["maxLength"]
+    }
+  },
+  "properties": {
+    "additionalItems": {"$ref": "#"},
+    "additionalProperties": {"$ref": "#"},
+    "dependencies": {
+      "additionalProperties": {
+        "anyOf": [{"type": "array"}, {"$ref": "#"}]
+      }
+    },
+    "items": {
+      "anyOf": [{"$ref": "#"}, {"$ref": "#/definitions/schemaArray"}]
+    },
+    "definitions": {
+      "additionalProperties": {"$ref": "#"}
+    },
+    "patternProperties": {
+      "additionalProperties": {"$ref": "#"}
+    },
+    "properties": {
+      "additionalProperties": {"$ref": "#"}
+    },
+    "if": {"$ref": "#"},
+    "then": {"$ref": "#"},
+    "else": {"$ref": "#"},
+    "allOf": {"$ref": "#/definitions/schemaArray"},
+    "anyOf": {"$ref": "#/definitions/schemaArray"},
+    "oneOf": {"$ref": "#/definitions/schemaArray"},
+    "not": {"$ref": "#"},
+    "contains": {"$ref": "#"},
+    "propertyNames": {"$ref": "#"}
+  }
+};function dt(t){return typeof t=="string"?t:t.toString()}function w(t,e){return Object.entries(t).reduce((i,[r,n])=>(i[r]=e(n),i),{})}async function H(t,e){const i=await Promise.all(Object.values(t).map(r=>e(r)));return Object.keys(t).reduce((r,n,o)=>(r[n]=i[o],r),{})}function V({payload:t,signatures:e,link:i}){return{payload:t,signatures:e,link:i?new nt(i):void 0}}function X({payload:t,signatures:e,link:i}){return{payload:t,signatures:e,link:i?.toString()}}function j({jws:t,linkedBlock:e}){return{jws:V(t),linkedBlock:rt(e,"base64pad")}}function M({jws:t,linkedBlock:e}){return{jws:X(t),linkedBlock:ot(e,"base64pad")}}function ht(t){return w(t,e=>e.map(j))}function ut(t){return w(t,e=>e.map(M))}function T(t){return{...t,commits:t.commits.map(j)}}function I(t){return{schemas:w(t.schemas,e=>({...e,commits:e.commits.map(j)})),definitions:w(t.definitions,T),tiles:w(t.tiles,T)}}function A(t){return{...t,commits:t.commits.map(M)}}function Q(t){return{schemas:w(t.schemas,e=>({...e,commits:e.commits.map(M)})),definitions:w(t.definitions,A),tiles:w(t.tiles,A)}}const k={anchor:!1};async function v(t,e,i={}){const r=await O.create(t,e,i,k);return await t.pin.add(r.id),r}async function S(t,[e,...i]){const r=await O.createFromGenesis(t,e,k);await t.pin.add(r.id);for(const n of i)await t.applyCommit(r.id,n,k);return r}async function ft(t,e){return await H(e,async i=>await S(t,i))}function b(t){if(t.$comment?.startsWith(B)){const e=t.$comment.substr(B.length);if(e.length){const i=e.split("|");return i.sort(),i}}return null}function $(t,e=""){if(t.type==="string"){const i=b(t);return i!=null&&i.length>0?{[e]:i}:{}}return t.type==="array"?$(t.items,e):t.type==="object"&&t.properties!=null?Object.entries(t.properties).reduce((i,[r,n])=>{const o=e===""?r:`${e}.${r}`;return Object.assign(i,$(n,o))},{}):{}}var z=(t,e,i)=>{if(!e.has(t))throw TypeError("Cannot "+i)},s=(t,e,i)=>(z(t,e,"read from private field"),i?i.call(t):e.get(t)),E=(t,e,i)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,i)},wt=(t,e,i,r)=>(z(t,e,"write to private field"),r?r.call(t,i):e.set(t,i),i),h,c,d,f,C;function pt(t){const e=typeof t=="string"?J.from(t):t;return[e.baseID.toString(),F.isInstance(e)?e.toString():null]}function K(t){return(typeof t=="string"?J.from(t):t).baseID.toString()}function _(t){return t.startsWith("did:key")}function Y(t){return _(t.metadata.controllers[0])}const St=I(st);async function W(t){await Promise.all(Object.values(St.schemas).map(async e=>await S(t,e.commits)))}async function x(t,e){const[i]=await Promise.all([Promise.all(Object.values(e.schemas).map(async o=>{const l=await S(t,o.commits);return[o.alias,l.commitId.toUrl()]})),W(t)]),[r,n]=await Promise.all([await Promise.all(Object.values(e.definitions).map(async o=>{const l=await S(t,o.commits);return[o.alias,l.id.toString()]})),await Promise.all(Object.values(e.tiles).map(async o=>{const l=await S(t,o.commits);return[o.alias,l.id.toString()]}))]);return{definitions:Object.fromEntries(r),schemas:Object.fromEntries(i),tiles:Object.fromEntries(n)}}async function yt(t,e){return await x(t,I(e))}const Z=class{constructor(t,e){E(this,h,{definitions:{},schemas:{},tiles:{}}),E(this,c,void 0),E(this,d,{definitions:{},schemas:{},tiles:{}}),E(this,f,{}),E(this,C,{}),wt(this,c,t),e!=null&&this.addModel(e)}static fromJSON(t,e){return new Z(t,I(e))}get model(){return s(this,d)}get schemas(){return Object.keys(s(this,h).schemas).sort()}get definitions(){return Object.keys(s(this,h).definitions).sort()}get tiles(){return Object.keys(s(this,h).tiles).sort()}addModel(t){Object.assign(s(this,d).definitions,t.definitions),Object.assign(s(this,d).schemas,t.schemas),Object.assign(s(this,d).tiles,t.tiles);for(const[e,i]of Object.entries(t.schemas)){s(this,h).schemas[i.alias]=e;for(const r of Object.values(i.dependencies))for(const n of r)s(this,f)[n]==null&&(s(this,f)[n]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[n].schemas.add(e)}for(const[e,i]of Object.entries(t.definitions))s(this,h).definitions[i.alias]=e,s(this,f)[i.schema]==null&&(s(this,f)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[i.schema].definitions.add(e);for(const[e,i]of Object.entries(t.tiles))s(this,h).tiles[i.alias]=e,s(this,f)[i.schema]==null&&(s(this,f)[i.schema]={definitions:new Set,schemas:new Set,tiles:new Set}),s(this,f)[i.schema].tiles.add(e)}addJSONModel(t){this.addModel(I(t))}async loadStream(t){const e=typeof t=="string"?t:t.baseID.toString();return s(this,C)[e]==null&&(s(this,C)[e]=this._loadAndValidateStream(e)),await s(this,C)[e]}async _loadAndValidateStream(t){const e=await O.load(s(this,c),t);if(e.anchorCommitIds.length!==0)throw new Error(`Invalid stream ${t}: contains anchor commit`);if(e.allCommitIds.length===1&&Y(e))return e;if((await Promise.all(e.allCommitIds.map(async n=>await O.load(s(this,c),n)))).find(n=>!Y(n))!=null)throw new Error(`Invalid stream ${t}: contains a commit authored by an unsupported DID`);return e}async loadCommits(t){return(await s(this,c).loadStreamCommits(t)).map(i=>i.value)}async loadSchema(t,e){const[i,r]=pt(t);if(r===null)throw new Error(`Expected CommitID to load schema: ${i}`);const n=s(this,d).schemas[i];if(n!=null){if(n.version!==r)throw new Error(`Another version for this schema is already set: ${n.version}`);if(e!=null&&n.alias!==e)throw new Error(`Another alias for this schema is already set: ${n.alias}`);return i}const[o,l]=await Promise.all([this.loadStream(r),this.loadCommits(i)]),a=o.content??{},m=e??a.title;if(m==null)throw new Error("Schema must have a title property or an alias must be provided");const u=await this.loadSchemaDependencies(a);return s(this,d).schemas[i]={alias:m,commits:l,dependencies:u,version:r},s(this,h).schemas[m]=i,i}async loadSchemaDependencies(t){const e=$(t),i=new Set;for(const o of Object.values(e))for(const l of o)i.add(l);const r=await Promise.all(Array.from(i).map(async o=>[o,await this.loadSchema(o)])),n=Object.fromEntries(r);return Object.entries(e).reduce((o,[l,a])=>(o[l]=a.map(m=>n[m]),o),{})}async create(t,e,i,r){switch(t){case"schema":return await this.createSchema(e,i);case"definition":return await this.createDefinition(e,i);case"tile":return await this.createTile(e,i,r);default:throw new Error(`Unsupported type: ${t}`)}}async usePublished(t,e,i){switch(t){case"schema":return await this.usePublishedSchema(e,i);case"definition":return await this.usePublishedDefinition(e,i);case"tile":return await this.usePublishedTile(e,i);default:throw new Error(`Unsupported type: ${t}`)}}getSchemaID(t){return s(this,h).schemas[t]??null}hasSchemaAlias(t){return this.getSchemaID(t)!=null}getSchema(t){return s(this,d).schemas[t]??null}getSchemaURL(t){const e=s(this,d).schemas[t];return e?F.fromString(e.version).toUrl():null}getSchemaByAlias(t){const e=this.getSchemaID(t);return e?this.getSchema(e):null}async createSchema(t,e){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!_(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasSchemaAlias(t))throw new Error(`Schema ${t} already exists`);const[i,r]=await Promise.all([v(s(this,c),e),this.loadSchemaDependencies(e)]),n=i.id.toString();return s(this,d).schemas[n]={alias:t,commits:await this.loadCommits(n),dependencies:r,version:i.commitId.toString()},s(this,h).schemas[t]=n,n}async usePublishedSchema(t,e){if(t==null)throw new Error("Schema alias must be provided");return await this.loadSchema(e,t)}getDefinitionID(t){return s(this,h).definitions[t]??null}hasDefinitionAlias(t){return this.getDefinitionID(t)!=null}getDefinition(t){return s(this,d).definitions[t]??null}async createDefinition(t,e){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!_(s(this,c).did.id))throw new Error(`Invalid DID ${s(this,c).did.id} to create stream for model, only "did:key" is supported`);if(this.hasDefinitionAlias(t))throw new Error(`Definition ${t} already exists`);await W(s(this,c));const[i,r]=await Promise.all([v(s(this,c),e,{schema:it}),this.loadSchema(e.schema)]),n=i.id.toString();return s(this,d).definitions[n]={alias:t,commits:await this.loadCommits(n),schema:r,version:i.commitId.toString()},s(this,h).definitions[t]=n,n}async usePublishedDefinition(t,e){if(this.hasDefinitionAlias(t))throw new Error(`Definition ${t} already exists`);const i=K(e),[r,n]=await Promise.all([this.loadStream(e),this.loadCommits(i)]);return s(this,d).definitions[i]={alias:t,commits:n,schema:await this.loadSchema(r.content.schema),version:r.commitId.toString()},s(this,h).definitions[t]=i,i}getTileID(t){return s(this,h).tiles[t]??null}hasTileAlias(t){return this.getTileID(t)!=null}getTile(t){return s(this,d).tiles[t]??null}async createTile(t,e,i={}){if(s(this,c).did==null||!s(this,c).did.authenticated)throw new Error("Ceramic instance must be authenticated");if(!_(s(this,c).did.id))throw new Error("Unsupported DID to create stream for model");if(this.hasTileAlias(t))throw new Error(`Tile ${t} already exists`);if(i.schema==null)throw new Error(`Missing schema to create tile ${t}`);const[r,n]=await Promise.all([v(s(this,c),e,i),this.loadSchema(i.schema)]),o=r.id.toString();return s(this,d).tiles[o]={alias:t,commits:await this.loadCommits(o),schema:n,version:r.commitId.toString()},s(this,h).tiles[t]=o,o}async usePublishedTile(t,e){if(this.hasTileAlias(t))throw new Error(`Tile ${t} already exists`);const i=K(e),[r,n]=await Promise.all([this.loadStream(e),this.loadCommits(i)]);if(r.metadata.schema==null)throw new Error("Loaded tile has no schema defined");return s(this,d).tiles[i]={alias:t,commits:n,schema:await this.loadSchema(r.metadata.schema),version:r.commitId.toString()},s(this,h).tiles[t]=i,i}async toPublished(){return await x(s(this,c),s(this,d))}toJSON(){return Q(s(this,d))}};let gt=Z;h=new WeakMap,c=new WeakMap,d=new WeakMap,f=new WeakMap,C=new WeakMap;function N(t,e=""){const i=ct(t);return i.startsWith(e)?i:e+i}function R(t,e,i,r){const n=e.title??"";if(e.type==="array")throw new Error("Unsupported item field of type array");if(e.type==="string"){const o=b(e);if(o==null)return{...e,type:"string"};const l=N(n,i),a={schemas:o,owner:r};return t.references[l]=a,{type:"reference",...a}}return e.type==="object"?{type:"object",name:P(t,e,{name:n,parent:i,owner:r})}:e}function P(t,e,i={}){const r=i.name??e.title;if(r==null)throw new Error("Schema must have a title");const n=N(r,i.parent);if(e.type==="string"){const o=b(e);o!=null&&(t.references[n]={schemas:o,owner:i.owner})}else if(e.type==="array"&&e.items!=null)t.lists[n]=R(t,e.items,n,i.owner);else if(e.type==="object"&&e.properties!=null){const o=e.required??[],l=Object.entries(e.properties).reduce((a,[m,u])=>{const y=u.title??m,p=at(m),g={name:y,parent:n,owner:i.owner??n},D=o.includes(m);if(u.type==="string"){const U=b(u);if(U==null)a[p]={...u,required:D,type:"string"};else{const et=N(y,n),L={schemas:U,owner:i.owner??n};t.references[et]=L,a[p]={required:D,type:"reference",...L}}}else if(u.type==="array"){if(u.items==null)throw new Error(`Missing items in field ${m}`);a[p]={required:D,type:"list",name:P(t,u,g)}}else u.type==="object"?a[p]={required:D,type:"object",name:P(t,u,g)}:a[p]={...u,required:D};return a},{});t.objects[n]={fields:l,parents:i.parent?[i.parent]:null}}return n}async function Dt(t){const e={collections:{},index:{},lists:{},objects:{},referenced:{},references:{},roots:{}},i=t.schemas.map(async o=>{const l=t.getSchemaID(o),a=await t.loadStream(l),m=a.content;if(m==null)throw new Error(`Could not load schema ${o}`);const u=a.commitId.toUrl();if(m.$comment?.startsWith(q)){const y=m.$comment.substr(q.length);await t.loadSchema(y);const g=(await t.loadStream(y)).content?.properties?.contents?.items?.oneOf?.[0];if(g==null)throw new Error(`Could not extract item schema ${o}`);e.collections[o]={schema:u,item:R(e,g,o,o)},e.referenced[u]={type:"collection",name:o}}else e.referenced[u]={type:"object",name:P(e,m)}}),r=t.definitions.map(async o=>{const l=t.getDefinitionID(o),a=await t.loadStream(l),m=a.content;if(m==null)throw new Error(`Could not load definition ${o}`);e.index[o]={id:a.id.toString(),schema:m.schema}}),n=t.tiles.map(async o=>{const l=t.getTileID(o),a=await t.loadStream(l),{schema:m}=a.metadata;if(m==null)throw new Error(`Missing schema for tile ${o}`);e.roots[o]={id:a.id.toString(),schema:m}});return await Promise.all([...i,...r,...n]),e}const tt=new G({strict:!1}).compile(mt);function It(t){const e=new G;return lt(e),e.compile(t),tt(t)}export{gt as ModelManager,P as addModelSchema,w as applyMap,Dt as createGraphQLModel,v as createModelDoc,V as decodeDagJWS,j as decodeDagJWSResult,T as decodeEntryCommits,I as decodeModel,ht as decodeSignedMap,X as encodeDagJWS,M as encodeDagJWSResult,A as encodeEntryCommits,Q as encodeModel,ut as encodeSignedMap,$ as extractSchemaReferences,R as getItemField,b as getReference,It as isSecureSchema,H as promiseMap,S as publishCommits,W as publishDataStoreSchemas,yt as publishEncodedModel,x as publishModel,ft as publishSignedMap,dt as streamIDToString,tt as validateSchemaSecure};
 //# sourceMappingURL=lib.mjs.map
